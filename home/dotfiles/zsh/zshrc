# Unalias conflicting commands
unalias l 2>/dev/null
unalias ls 2>/dev/null

if [ -z "$SSH_AUTH_SOCK" ]; then
   eval $(ssh-agent) > /dev/null
fi

# Custom prompt function
prompt_setup() {
    # Capture last exit status
    local last_status=$?
    
    # Check if we're in a nix shell or nix develop environment
    local nix_indicator=""
    if [[ -n "$IN_NIX_SHELL" ]]; then
        if [[ "$IN_NIX_SHELL" == "impure" ]]; then
            nix_indicator="%F{blue}[nix-shell]%f "
        else
            nix_indicator="%F{cyan}[nix-shell:pure]%f "
        fi
    elif [[ -n "$NIX_BUILD_TOP" ]]; then
        nix_indicator="%F{magenta}[nix-develop]%f "
    fi
    
    # Git branch
    local git_branch=""
    if command -v git >/dev/null 2>&1; then
        if git rev-parse --git-dir >/dev/null 2>&1; then
            local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
            if [[ -n "$branch" ]]; then
                git_branch=" %F{yellow}($branch)%f"
            fi
        fi
    fi
    
    # Exit status indicator
    local status_indicator=""
    if [[ $last_status -ne 0 ]]; then
        status_indicator=" %F{red}[$last_status]%f"
    fi
    
    # Build prompt
    PROMPT="${nix_indicator}%F{white}%n%f %F{cyan}%~%f${git_branch}${status_indicator} $ "
}

precmd() {
    prompt_setup
}

# Tree listing function with level parameter
l() {
    local level=1
    local args=()
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -l)
                if [[ $# -ge 2 ]]; then
                    level=$2
                    shift 2
                    continue
                fi
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    eza -a --tree --level=$level --icons "${args[@]}"
}

# Enhanced navigation functions
cd() {
    if [[ $# -eq 0 ]]; then
        z "$HOME"
    else
        z "$@"
    fi
}

# Enhanced fzf function with clipboard integration
fzf() {
    local selection
    selection=$(command fzf "$@")
    if [[ -n "$selection" ]]; then
        echo "$selection" | wl-copy
        echo "$selection"
    fi
}

# Custom functions
dcp() {
    if [[ -z "$1" ]]; then
        echo "Usage: dcp <file or directory>"
        return 1
    fi
    local dir=$(realpath "$1")
    echo -n "$dir" | wl-copy
    echo "Copied to clipboard: $dir"
}

dcut() {
    if [[ -z "$1" ]]; then
        echo "Usage: dcut <file or directory>"
        return 1
    fi
    local dir=$(realpath "$1")
    echo -n "CUT:$dir" | wl-copy
    echo "Cut to clipboard: $dir"
}

dpaste() {
    local dest=${1:-.}
    local clip=$(wl-paste)
    if [[ "$clip" == CUT:* ]]; then
        local dir="${clip#CUT:}"
        mv "$dir" "$dest"
        echo "Moved: $dir -> $dest"
    else
        cp -r "$clip" "$dest"
        echo "Copied: $clip -> $dest"
    fi
}

make-flake() {
    local flakefile="flake.nix"
    if [[ -e "$flakefile" ]]; then
        echo "$flakefile already exists. Aborting." >&2
        return 1
    fi
    cp ~/nixos-configuration/templates/flake.nix "$flakefile"
    echo "Created $flakefile from ~/nixos-configuration/templates/flake.nix in $(pwd)"
}

nix-develop() {
    nix develop "$@" --command env SHELL=$(which zsh) zsh --login
}

nix-shell() {
    export NIX_SHELL="$@"
    command nix-shell "$@" --run "env SHELL=$(which zsh) zsh --login"
}

nxreb() {
    source ~/nixos-configuration/.env
    sudo nixos-rebuild switch --flake ~/nixos-configuration/#$NIX_HOST
}

nxupdate() {
    source ~/nixos-configuration/.env
    sudo nix flake update
    sudo nixos-rebuild switch --flake ~/nixos-configuration/#$NIX_HOST
}

vfzf() {
    local cols=$(tput cols)
    local file
    if (( cols > 160 )); then
        file=$(fzf --height=70% --layout=reverse --info=inline --border --margin=1 --padding=1 \
            --preview 'bat --color=always --style=header,grid --line-range :300 {}' \
            --preview-window 'right:50%:wrap')
    else
        file=$(fzf --height=70% --layout=reverse --info=inline --border --margin=1 --padding=1)
    fi
    if [[ -n "$file" ]]; then
        $EDITOR "$file"
    fi
}
